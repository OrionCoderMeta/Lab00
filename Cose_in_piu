0. GET_YEARS

@staticmethod
    def getYears():
        cnx = DBConnect.get_connection()
        result = []
        if cnx is None:
            print("Connessione fallita")
        else:
            cursor = cnx.cursor(dictionary=True)
            query = """select distinct s.`year` as anno
                        from seasons s
                        order by s.`year` desc """
            cursor.execute(query)

            for row in cursor:
                result.append(row["anno"])
            cursor.close()
            cnx.close()
        return result

1. DRIVER per l'anno che hanno tagliato il traguardo

select DISTINCT d.driverId as driverID, d.forename as name, d.surname as surname
from drivers d, races r, results r2
where d.driverId = r2.driverId and r.raceId = r2.raceId
and r2.`position` is not null
and YEAR(r.date) = %s

2. se c'è def getAllEdges(dMin): allora ci sarà --> cursor.execute(query, (dMin,))
    se sono 2 allora (dMin, dMax) 3 (dMin, dMax, dCC) ...

3. numero di nodi collegati al nodo n --> self._graph.degree(n)

4. lista dei nodi raggiungibili da nodo --> componenti = nx.node_connected_component(self._graph, nodo)

6 .Per iterare su ogni nodo raggiungibile da un nodo
raggiungibili = nx.node_connected_component(G, nodo)
for comp in raggiungibili:
    print("Nodo:", comp)
Nel caso però il grafo NON fosse orientato
nx.descendants(G, nodo) → tutti i nodi raggiungibili in avanti da nodo
nx.ancestors(G, nodo) → tutti i nodi che possono raggiungere nodo
nx.strongly_connected_components(G) → per trovare componenti fortemente connesse
nx.weakly_connected_components(G) → per trovare componenti debolmente connesse

8. se voglio iterare e aggiungere il peso degli archi:
    def addVolume(self):
        for nodo in self._graph.nodes():
            volume = 0
            for u, v in self._graph.edges(nodo):
                peso = self._graph[u][v]['weight']
                volume += peso
            nodo.setVolume(volume)

9. ordinamento decrescente per peso -> # Ordinamento decrescente per volume
        sorted_nodes = sorted(self._graph.nodes(), key=lambda v: v.peso, reverse=True)




